# erlarg
[![erlarg CI](https://github.com/Eptwalabha/erlarg/actions/workflows/erlang.yml/badge.svg)](https://github.com/Eptwalabha/erlarg/actions/workflows/erlang.yml)

An Erlang lib that parsed a list of arguments into a structured tree.  
Useful for handling options/parameters of escript

> [!WARNING]
> This lib is under development and is likely to change in the future (see [TODO](#todo) section).  
> If you need a working alternative, you can use [getopt](https://github.com/jcomellas/getopt).

## Installation

Add `erlarg` to in the `deps` of your `rebar.config`:
```erlang
{erlarg, {git, "https://github.com/Eptwalabha/erlarg.git", {branch, "master"}}}
```
If you're building an `escript`, add `erlarg` to the list of apps to include in the binary
```erlang
{escript_incl_apps, [erlarg, …]}.
```
fetch and compile the dependencies of your project:
```bash
rebar3 compile --deps_only
```
That's it, you're good to go.

## Usage
The function `erlarg:parse/2` will transforme the list of arguments passed to your script into a structured data.
- `Args`: the list of arguments
- `Spec`: A spec that explains how the arguments should be parsed


For the following script and arguments :
```bash
./my-script --limit=20 -m 0.25 --format "%s%t" -o output.tsv -
```
The `main/1` function of said script will receive this list of arguments:
```erlang
["--limit=20", "-m", "0.25", "--format", "%s%t", "-o", "output.tsv", "-"]
```
`erlarg:parse/2` will help you convert them into a structured data:
```erlang
main(Args) ->
    Spec = {any, [{limit, erlarg:opt({"-l", "--limit"}, int)},
                  {format, erlarg:opt({"-f", "--format"}, binary)},
                  {file, erlarg:opt("-o", string)},
                  {stdin, erlarg:opt("-")},
                  {max, erlarg:opt({"-m", "--max"}, float)}
                  ]}
    {ok, {Options, RemainingArgs} = erlarg:parse(Args, Spec),
    ...
```
In this exemple, `parse` will returns:
```erlang
{ok, {[{limit, 20},
       {max, 0.25},
       {format, <<"%s%t">>},
       {file, "output.tsv"},
       stdin], []}}.
```


### Syntax

The syntax will describe to the parser how to handle each arguments from `Args`.
It will try to consume them one by one and will build the structured data while doing so.

lets take an example:
```bash
# this fictionnal script takes a string and print it n time
$ duplicate "hello" 3
```
The simplest spec needed to handle the arguments:
```erlang
Syntax = [string, int].
erlarg:parse(Args, Syntax). % in this example Args = ["hello", "3"]
% will return
{ok, {["hello", 3], []}}
```
Here, we explicitly ask the parser to handle two arguments, the first argument must be a `string`, the second an `int`.  
In case of successful parsing, it will return the following tuple:
```erlang
{ok, {Data, RemainingArgs}}.
```
`Data` is the structured data generated by the parser (`["hello", 3]`)  
`RemainingArgs` are the list of arguments not consumed. (`[]`)

### Remaining Args

`RemainingArgs` are the arguments that the parser did not consume.  
If we take our previous example, but this time we add some extra arguments at the end:
```bash
$ duplicate "hello" 3 how are you
```
calling `erlarg:parse/2` with the same syntax as before will give this result:
```erlang
Syntax = [string, int].
{ok, {_, ["how", "are", "you"]}} = erlarg:parse(Args, Syntax).
```
That's because in this case, the syntax is only expecting two arguments. Every arguments not consumed once the syntax ends is returns in the `RemainingArgg`.

### All base types
Here all the types that can be handled by the parser:
- `int`: cast the argument into an int
- `float`: cast the argument into a float (will cast int into float)
- `number`: cast the argument into an int. If it fails it will cast the argument into a float
- `string`: returns the given argument
- `binary`: cast the argument into a binary list
- `atom`: cast the arg to an atom
- `bool`: return the boolean value of the arg

| syntax | arg | result | note |
|---|---|---|---|
| int | "1" | 1 |-|
| int | "1.2" | error | not an int |
| float | "1.2" | 1.2 |-|
| float | "1" | 1.0 | cast int into float |
| float | "1.234e2" | 123.4 |-|
| number | "1" | 1 |-|
| number | "1.2" | 1.2 |-|
| string | "abc" | "abc" | does nothing |
| binary | "äbc" | <<"äbc"/utf8>> | use `unicode:characters_to_binary`|
| atom | "super-top" | 'super-top' |-|

the `bool` conversion:
| arg | bool | note |
|---|---|---|
| "true" | true | case insensitive |
| "yes" | true ||
| "abcd" | true | any non-empty string |
| "1" | true ||
| "0.00001" | true ||
| "false" | false | case insensitive |
| "no" | false ||
| "" | false | empty-string|
| "0" | false ||
| "0.0" | false ||

> [!NOTE]
> When the parser is task to convert an argument as `string`, `binary`, `bool` or `atom` it will always succeed and consume the argument.
> This detail can be important for some operator like `any`

### Give names to our parameters

Parsing the type of argument is nice, but it does not really help us understand what this parameters are for.  
If we take our last example:
```bash
$ duplicate "hello" 3
```
The first version of our syntax will return:
```
["hello", 3].
```
That's nice, but not really helpful… It'll be nicer to have "name" to the parsed parameters. We can archieve that with the following syntax:
```erlang
{Name :: atom(), Type :: base_type()}
```
Now, if we update our syntax:
```
Syntax = [{sentence, string()}, {nbr_copy, int}].
```
The parser will return this:
``` erlang
[{sentence, "hello"}, {nbr_copy, 3}]
```

### Options
TODO

### operator `and`
format:
```
[syntax()]
```
All elements of the list must succeed in order for the operator to succeed.  
| syntax | args | result | note |
|---|---|---|---|
| [int, string] | ["1", "a"] | [1, "a"] |-|
| [int] | ["1", "a"]  | [1]| remaining: ["a"] |
| [string] | ["1", "a"]  | ["1"] | remaining: ["a"] |-|
| [{key, float}] | ["1.2"] | [{key, 1.2}] |-|
| [int, int] | ["1", "a"] | error | "a" isn't an int |
| [int, string, int] | error | missing third arg |
| [{opt1, int}, {opt2, int}] | ["1", "a"] | error | "a" isn't an int |

### operator `any`
format:
```
{any, [syntax()]}
```
The parser will try to consume arguments as long as one of syntax matches. If an element of the syntax fails, the operator fails.  
| syntax | args | result | note |
|---|---|---|---|
| {any, [int]} | ["1", "2", "abc"] | [1, 2] | remaining: ["abc"] |
| {any, [{key, int}]} | ["1", "2"] | [{key, 1}, {key, 2}] |-|
| {any, [int, {s, string}]} | ["1", "2", "abc", "3"] | [1, 2, {s, "abc"}, 3] |-|
| {any, [string]} | ["1", "-o", "abc", "3"] | ["1", "-o", "abc", "3"] | even if "-o" is an option|

No matter the number of matching element, `any` will always succeed. If nothing matches no arguments will be consumed.

> [!NOTE]
> Keep in mind that if the list given to `any` contains types like `string` or `binary`, it will consume all the remaining arguments.  
> `{any, [string, custom_type]}`, `custom_type` will never be executed because the type `string` will always consume argument

### operator `first`
format:
```
{first, [syntax()]}
```
The parser will return the first element of the syntax to succeed.
It'll fail if no element matches.  
The following table use `Args = ["a", "b", "1"]`
| syntax | result | remaining | note |
|---|---|---|---|
| {first, [int]} | [1] | ["2", "a", "3", "b"] |-|
| {first, [{opt, int}]} | [{opt, 1}] | ["a", "3", "b"] |-|
| {any, [int, {b, binary}]} | [1, 2, {b, <<"a">>}, 3, {b, <<"b">>}] | [] |-|
| {any, [string]} | ["1", "2", "a", "3", "b"] | [] |-|

### custom type

This lib allows you to define your own type. It's especially usefull when you need to perfom some operation on the argument or if you need to do more complexe verification.  

Your custom type is a function that takes a list of argument and return the formated / checked value to the parser:
```
-spec fun((Args :: args()) -> {ok, Value :: any(), Remaining :: args} | Failure :: any()).
```
- `Args`: The list of arguments not yet consumed by the parser
- `Value`: The Value you want to return to the parser
- `Remaining`: The list of arguments your function didn't consumed

**Example 1**:  
Let say your script has an option `-f FILE` where `FILE` must be an existing file. In this case the type `string` is not enought, so you could make your own function that does this check:
```erlang
existing_file([File | RemainingArgs]) ->
    case filelib:is_regular(File) of
        true ->
            {ok, File, RemainingArgs};
        _ ->
            {not_a_file, File}
    end.
```
To use your custom type:
```erlang
Spec = #{ syntax => {any, [file]},
          definitions => #{ file => erlarg:opt("-f", existing_file),
                            existing_file => fun existing_file/1 } }.
```
or more simply:
```erlang
{any, [{file, erlarg:opt("-f", fun existing_file/1)}]}
```

**Example 2**:  
In this case, your script needs to fetch the informations of a particular user from a config file with the option `--consult USERS_FILE USER_ID` where `CONFIG` is the location of the database file and `USER_ID` is the id of the user:
```erlang
get_user_config([DatabaseFile, UserID | RemainingArgs]) ->
    case file:consult(DatabaseFile) of
        {ok, Users} ->
            case proplists:get_value(UserID, Users, not_found) of
                not_found -> {user_not_found, UserID};
                UserData -> {ok, UserData, RemainingArgs}
            end;
        Error -> {cannot_consult, DatabaseFile, Error}
    end;
get_user_config(_) ->
    {badarg, missing_arguments}.
```

**Examples 3**:  
The results of the following table use the type `my_type` defined by the following function:
```
my_type(["c:" ++ Arg | Args]) ->
    {ok, {cust, Arg}, Args};
my_type(_) ->
    fails.
```
| syntax | args | result | remaining | note |
|---|---|---|---|---|
| [my_type] | ["c:abc"] | [{cust, "abc"}] | [] |-|
| {any, [my_type, int]} | ["1", "c:abc", "other"] | [1, {cust, "abc"}] | ["other"] |-|
| [my_type, my_type] | ["c:abc", "other] | error | ["c:abc", "other] | the second arg does not match type `my_type` |
| [{opt1, binary}] | [{opt1, <<"1">>}] | ["a"] |-|
| [int, int] | error | ["1", "a"] | "a" isn't an int |
| [int, string, int] | error | ["1", "a"] | missing third arg |
| [{opt1, int}, {opt2, int}] | error | ["1", "a"] | "a" isn't an int |

## TODO

> [!NOTE]
> This lib will enter v1.0.0 once the remaining points bellow are dealt with

- [ ] complete README.md
- [ ] prevent infinite / cyclic recursion

additional features (plan for next version):
- [ ] `erlarg:usage/1`
- [ ] `--` (see: https://unix.stackexchange.com/a/11382)
- [ ] optimize the spec
- [ ] operator `once`
- [ ] operator `not`