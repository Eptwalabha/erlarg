# erlarg
[![erlarg CI](https://github.com/Eptwalabha/erlarg/actions/workflows/ci.yml/badge.svg)](https://github.com/Eptwalabha/erlarg/actions/workflows/ci.yml)

An Erlang lib that parsed a list of arguments into a structured tree.  
Useful for handling options/parameters of escript

> [!WARNING]
> This lib is under development and is likely to change in the future (see [TODO](#todo) section).  
> If you need a working alternative, you can use [getopt](https://github.com/jcomellas/getopt).

## Installation

Add `erlarg` to in the `deps` of your `rebar.config`:
```erlang
{erlarg, {git, "https://github.com/Eptwalabha/erlarg.git", {branch, "master"}}}
```
If you're building an `escript`, add `erlarg` to the list of apps to include in the binary
```erlang
{escript_incl_apps, [erlarg, …]}.
```
fetch and compile the dependencies of your project:
```bash
rebar3 compile --deps_only
```
That's it, you're good to go.

## Usage
The function `erlarg:parse/2` will transforme the list of arguments passed to your script into a structured data.
- `Args`: the list of arguments
- `Spec`: A spec that explains how the arguments should be parsed


For the following script and arguments :
```bash
./my-script --limit=20 -m 0.25 --format "%s%t" -o output.tsv -
```
The `main/1` function of said script will receive this list of arguments:
```erlang
["--limit=20", "-m", "0.25", "--format", "%s%t", "-o", "output.tsv", "-"]
```
`erlarg:parse/2` will help you convert them into a structured data:
```erlang
main(Args) ->
    Spec = {any, [{limit, erlarg:opt({"-l", "--limit"}, int)},
                  {format, erlarg:opt({"-f", "--format"}, binary)},
                  {file, erlarg:opt("-o", string)},
                  {stdin, erlarg:opt("-")},
                  {max, erlarg:opt({"-m", "--max"}, float)}
                  ]}
    {ok, {Options, RemainingArgs} = erlarg:parse(Args, Spec),
    ...
```
In this exemple, `parse` will returns:
```erlang
{ok, {[{limit, 20},
       {max, 0.25},
       {format, <<"%s%t">>},
       {file, "output.tsv"},
       stdin], []}}.
```


### Syntax

The syntax will describe to the parser how to handle each arguments (`Args`).
The parser will then try to consume the arguments one by one and build the structured data while doing so.

Imagine this fictionnal script `print_n_time` that takes a string and an integer as argument
```bash
# this will print the string "hello" 3 times
$ print_n_time hello 3
```
Here's the simplest spec needed to handle the arguments:
```erlang
Syntax = [string, int].
erlarg:parse(Args, Syntax). % in this example Args = ["hello", "3"]
% will return
{ok, {["hello", 3], []}}
```
Here, we explicitly ask the parser to handle two arguments, the first argument must be a `string`, the second must be an `int`.  
If successful, the parser will return the following tuple:
```erlang
{ok, {Data, RemainingArgs}}.
```
`Data` is the structured data generated by the parser (`["hello", 3]`)  
`RemainingArgs` is the list of arguments not consumed by the parser (`[]`).  

### Parsing failure

The parser will fails if it cannot parse the argument:
```erlang
> erlarg:parse(["world"], [int]).
{error, {not_int, "word"}}
```
or if the syntax didn't get all the argument it needs
```erlang
> erlang:parse(["one"], [string, string]). % expect two strings but only got one
{error, {missing, arg}}
```

### Remaining Args

In the previous `print_n_time` example, all arguments where consumed, but if we add some extra arguments at the end of our command:
```bash
$ print_n_time hello 3 some extra arguments
```
this time, calling `erlarg:parse/2` with the same syntax as before will give this result:
```erlang
Syntax = [string, int].
{ok, {_, ["some", "extra", "arguments"]}} = erlarg:parse(Args, Syntax).
```
Because the syntax is only expecting two arguments, all the others where added to the `RemainingArgs`.

> [!NOTE]
> Having unconsumed argument does not generate an error

### All base types
The parser can convert the argument to more types than just `string` and `int`.  
Here are all the types currently available :

- `int`: cast the argument into an int
- `float`: cast the argument into a float (will cast int into float)
- `number`: cast the argument into an int. If it fails it will cast the argument into a float
- `string`: returns the given argument
- `binary`: cast the argument into a binary list
- `atom`: cast the arg to an atom
- `bool`: return the boolean value of the arg

| syntax | arg | result | note |
|---|---|---|---|
| int | "1" | 1 |-|
| int | "1.2" | error | not an int |
| float | "1.2" | 1.2 |-|
| float | "1" | 1.0 | cast int into float |
| float | "1.234e2" | 123.4 |-|
| number | "1" | 1 |-|
| number | "1.2" | 1.2 |-|
| string | "abc" | "abc" | does nothing |
| binary | "äbc" | <<"äbc"/utf8>> | use `unicode:characters_to_binary`|
| atom | "super-top" | 'super-top' |-|

the `bool` conversion:
| arg | bool | note |
|---|---|---|
| "true" | true | case insensitive |
| "yes" | true ||
| "abcd" | true | any non-empty string |
| "1" | true ||
| "0.00001" | true ||
| "false" | false | case insensitive |
| "no" | false ||
| "" | false | empty-string|
| "0" | false ||
| "0.0" | false ||

> [!TIP]
> converting an argument into `string`, `binary`, `bool` or `atom` it will always succeed.

### Give names to our parameters

Parsing the type of argument is nice, but it does not really help us understand what this parameters are for.  
If we take our last example:
```bash
$ print_n_time "hello" 3
```
The first version of our syntax will return:
```erlang
["hello", 3].
```
That's nice, but not really helpful… It'll be nice to "name" the parsed parameters. This can be archieved with the following syntax:
```erlang
{Name :: atom(), Type :: base_type()}
```
Now, if we update our syntax:
```
Syntax = [{words, string()}, {nbr, int}].
```
The parser will return this:
``` erlang
[{words, "hello"}, {nbr, 3}]
```

### Options


### operator `and`
format:
```
[syntax()]
```
All elements of the list must succeed in order for the operator to succeed.  
| syntax | args | result | note |
|---|---|---|---|
| [int, string] | ["1", "a"] | [1, "a"] |-|
| [int] | ["1", "a"]  | [1]| remaining: ["a"] |
| [string] | ["1", "a"]  | ["1"] | remaining: ["a"] |-|
| [{key, float}] | ["1.2"] | [{key, 1.2}] |-|
| [int, int] | ["1", "a"] | error | "a" isn't an int |
| [int, string, int] | error | missing third arg |
| [{opt1, int}, {opt2, int}] | ["1", "a"] | error | "a" isn't an int |

### operator `any`
format:
```
{any, [syntax()]}
```
The parser will try to consume arguments as long as one of syntax matches. If an element of the syntax fails, the operator fails.  
| syntax | args | result | note |
|---|---|---|---|
| {any, [int]} | ["1", "2", "abc"] | [1, 2] | remaining: ["abc"] |
| {any, [{key, int}]} | ["1", "2"] | [{key, 1}, {key, 2}] |-|
| {any, [int, {s, string}]} | ["1", "2", "abc", "3"] | [1, 2, {s, "abc"}, 3] |-|
| {any, [string]} | ["1", "-o", "abc", "3"] | ["1", "-o", "abc", "3"] | even if "-o" is an option|

No matter the number of matching element, `any` will always succeed. If nothing matches no arguments will be consumed.

> [!NOTE]
> Keep in mind that if the list given to `any` contains types like `string` or `binary`, it will consume all the remaining arguments.  
> `{any, [string, custom_type]}`, `custom_type` will never be executed because the type `string` will always consume argument

### operator `first`
format:
```
{first, [syntax()]}
```
The parser will return the first element of the syntax to succeed.
It'll fail if no element matches.  
The following table use `Args = ["a", "b", "1"]`
| syntax | result | remaining | note |
|---|---|---|---|
| {first, [int]} | [1] | ["2", "a", "3", "b"] |-|
| {first, [{opt, int}]} | [{opt, 1}] | ["a", "3", "b"] |-|
| {any, [int, {b, binary}]} | [1, 2, {b, <<"a">>}, 3, {b, <<"b">>}] | [] |-|
| {any, [string]} | ["1", "2", "a", "3", "b"] | [] |-|

### custom type

This lib allows you to define your own type. It's especially usefull when you need to perfom some operation on the argument or if you need to do more complexe verification.  

Your custom type is a function that takes a list of argument and return the formated / checked value to the parser:
```
-spec fun((Args :: args()) -> {ok, Value :: any(), Remaining :: args} | Failure :: any()).
```
- `Args`: The list of arguments not yet consumed by the parser
- `Value`: The Value you want to return to the parser
- `Remaining`: The list of arguments your function didn't consumed

**Example 1**:  
Let say your script has an option `-f FILE` where `FILE` must be an existing file. In this case the type `string` is not enought, so you could make your own function that does this check:
```erlang
existing_file([File | RemainingArgs]) ->
    case filelib:is_regular(File) of
        true ->
            {ok, File, RemainingArgs};
        _ ->
            {not_a_file, File}
    end.
```
To use your custom type:
```erlang
Spec = #{ syntax => {any, [file]},
          definitions => #{ file => erlarg:opt("-f", existing_file),
                            existing_file => fun existing_file/1 } }.
```
or more simply:
```erlang
{any, [{file, erlarg:opt("-f", fun existing_file/1)}]}
```

**Example 2**:  
In this case, your script needs to fetch the informations of a particular user from a config file with the option `--consult USERS_FILE USER_ID` where `CONFIG` is the location of the database file and `USER_ID` is the id of the user:
```erlang
get_user_config([DatabaseFile, UserID | RemainingArgs]) ->
    case file:consult(DatabaseFile) of
        {ok, Users} ->
            case proplists:get_value(UserID, Users, not_found) of
                not_found -> {user_not_found, UserID};
                UserData -> {ok, UserData, RemainingArgs}
            end;
        Error -> {cannot_consult, DatabaseFile, Error}
    end;
get_user_config(_) ->
    {badarg, missing_arguments}.
```

**Examples 3**:  
The results of the following table use the type `my_type` defined by the following function:
```
my_type(["c:" ++ Arg | Args]) ->
    {ok, {cust, Arg}, Args};
my_type(_) ->
    fails.
```
| syntax | args | result | remaining | note |
|---|---|---|---|---|
| [my_type] | ["c:abc"] | [{cust, "abc"}] | [] |-|
| {any, [my_type, int]} | ["1", "c:abc", "other"] | [1, {cust, "abc"}] | ["other"] |-|
| [my_type, my_type] | ["c:abc", "other] | error | ["c:abc", "other] | the second arg does not match type `my_type` |
| [{opt1, binary}] | [{opt1, <<"1">>}] | ["a"] |-|
| [int, int] | error | ["1", "a"] | "a" isn't an int |
| [int, string, int] | error | ["1", "a"] | missing third arg |
| [{opt1, int}, {opt2, int}] | error | ["1", "a"] | "a" isn't an int |

## TODO

> [!NOTE]
> This lib will enter v1.0.0 once the remaining points bellow are dealt with

- [ ] prevent infinite / cyclic recursion

additional features (plan for next version):
- [ ] `erlarg:usage/1`
- [ ] `--` (see: https://unix.stackexchange.com/a/11382)
- [ ] optimize the spec
- [ ] operator `once`