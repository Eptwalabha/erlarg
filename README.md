# erlarg
[![erlarg CI](https://github.com/Eptwalabha/erlarg/actions/workflows/ci.yml/badge.svg)](https://github.com/Eptwalabha/erlarg/actions/workflows/ci.yml)

An Erlang lib that parsed a list of arguments into a structured tree.  
Useful for handling options/parameters of escript

> [!WARNING]
> This lib is under development and is likely to change in the future (see [TODO](#todo) section).  
> If you need a working alternative, you can use [getopt](https://github.com/jcomellas/getopt).

## Installation

Add `erlarg` to in the `deps` of your `rebar.config`:
```erlang
{erlarg, {git, "https://github.com/Eptwalabha/erlarg.git", {branch, "master"}}}
```
If you're building an `escript`, add `erlarg` to the list of apps to include in the binary
```erlang
{escript_incl_apps, [erlarg, …]}.
```
fetch and compile the dependencies of your project:
```bash
rebar3 compile --deps_only
```
That's it, you're good to go.

## Usage
The function `erlarg:parse/2` will transforme the list of arguments passed to your script into a structured data.
- `Args`: the list of arguments
- `Spec`: A spec that explains how the arguments should be parsed


For the following script and arguments :
```bash
./my-script --limit=20 -m 0.25 --format "%s%t" -o output.tsv -
```
The `main/1` function of said script will receive this list of arguments:
```erlang
["--limit=20", "-m", "0.25", "--format", "%s%t", "-o", "output.tsv", "-"]
```
`erlarg:parse/2` will help you convert them into a structured data:
```erlang
main(Args) ->
    Spec = {any, [{limit, erlarg:opt({"-l", "--limit"}, int)},
                  {format, erlarg:opt({"-f", "--format"}, binary)},
                  {file, erlarg:opt("-o", string)},
                  {stdin, erlarg:opt("-")},
                  {max, erlarg:opt({"-m", "--max"}, float)}
                  ]}
    {ok, {Options, RemainingArgs} = erlarg:parse(Args, Spec),
    ...
```
In this exemple, `parse` will returns:
```erlang
{ok, {[{limit, 20},
       {max, 0.25},
       {format, <<"%s%t">>},
       {file, "output.tsv"},
       stdin], []}}.
```


### Syntax

The syntax will describe to the parser how to handle each arguments (`Args`).
The parser will then try to consume the arguments one by one and build the structured data while doing so.

Imagine this fictionnal script `print_n_time` that takes a string and an integer as argument
```bash
# this will print the string "hello" 3 times
$ print_n_time hello 3
```
Here's the simplest spec needed to handle the arguments:
```erlang
Syntax = [string, int].
erlarg:parse(Args, Syntax). % in this example Args = ["hello", "3"]
% will return
{ok, {["hello", 3], []}}
```
Here, we explicitly ask the parser to handle two arguments, the first argument must be a `string`, the second must be an `int`.  
If successful, the parser will return the following tuple:
```erlang
{ok, {Data, RemainingArgs}}.
```
`Data` is the structured data generated by the parser (`["hello", 3]`)  
`RemainingArgs` is the list of arguments not consumed by the parser (`[]`).  

### Parsing failure

The parser will fails if it cannot parse the argument:
```erlang
> erlarg:parse(["world"], [int]).
{error, {not_int, "word"}}
```
or if the syntax didn't get all the argument it needs
```erlang
> erlang:parse(["one"], [string, string]). % expect two strings but only got one
{error, {missing, arg}}
```

### Remaining Args

In the previous `print_n_time` example, all arguments where consumed, but if we add some extra arguments at the end of our command:
```bash
$ print_n_time hello 3 some extra arguments
```
this time, calling `erlarg:parse/2` with the same syntax as before will give this result:
```erlang
Syntax = [string, int].
{ok, {_, ["some", "extra", "arguments"]}} = erlarg:parse(Args, Syntax).
```
The parser will consume the two first arguments, the remaining argument will be returned in the `RemainingArgs`.

> [!NOTE]
> Having unconsumed arguments does not generate an error

### All base types
The parser can convert the argument to more types than just `string` and `int`.  
Here are all the types currently available :

- `int`: cast the argument into an int
- `float`: cast the argument into a float (will cast int into float)
- `number`: cast the argument into an int. If it fails it will cast the argument into a float
- `string`: returns the given argument
- `binary`: cast the argument into a binary list
- `atom`: cast the arg to an atom
- `bool`: return the boolean value of the arg

| syntax | arg | result | note |
|---|---|---|---|
| int | "1" | 1 |-|
| int | "1.2" | error | not an int |
| float | "1.2" | 1.2 |-|
| float | "1" | 1.0 | cast int into float |
| float | "1.234e2" | 123.4 |-|
| number | "1" | 1 |-|
| number | "1.2" | 1.2 |-|
| string | "abc" | "abc" |-|
| binary | "äbc" | <<"äbc"/utf8>> | use `unicode:characters_to_binary`|
| atom | "super-top" | 'super-top' |-|

the `bool` conversion:
| arg | bool | note |
|---|---|---|
| "true" | true | case insensitive |
| "yes" | true ||
| "abcd" | true | any non-empty string |
| "1" | true ||
| "0.00001" | true ||
| "false" | false | case insensitive |
| "no" | false ||
| "" | false | empty-string|
| "0" | false ||
| "0.0" | false ||

> [!TIP]
> converting an argument into `string`, `binary`, `bool` or `atom` it will always succeed.


### Naming the parsed values

Converting an argument into a specific type is important, but does not really help us understand what these values are for:  
```erlang
> Syntax = [string, int].
> {ok, {Result, _}} = erlarg:parse(["hello", "3"], Syntax).
["hello", 3]. % Result
```
The parser allows you to "name" value with the following syntax:
```erlang
{Name :: atom(), Type :: base_type()}
```
If we rewrite the syntax as such:
```erlang
> Syntax = [{sentence_to_print, string()}, {nbr_of_copy, int}].
> {ok, {Result, _}} = erlarg:parse(["hello", "3"], Syntax).
[{sentence_to_print, "hello"}, {nbr_of_copy, 3}]. % Result
```

### Options
Most program use options:
```bash
$ tar --list --file FILE
```
`erlarg` can handle two kind of options:
- without parameter
- with parameters
- with sub options

An option can be defined with `erlarg:opt` as such:
```erlang
> FileOpt = erlarg:opt({"-f", "--file"}, file, string),
```
This will parse options that are written these ways:
```
-f my-file.tsv
--file my-file.tsv
--file=my-file.tsv
```
> [!NOTE]
> The parser does not currently handle combined short options (i.e: `tar -xzf`).  
> This feature is expected for future version.

The first parameter of `erlarg:opt` is the option used:
| | short | long | note |
|---|---|---|---|
| {"-f", "--file"} | "-f" | "--file" | |
| "-f" | "-f" | undefined | no long option |
| { undefined, "--file" } | undefined | "--file" | no short option |

The second parameter is its name in `atom()`
The third (and optional) parameter is the syntax expected by this option. It can be anything, a type (basic or custom), a list of options, a complex syntax or even `undefined`.




### operator `and`
format:
```
[syntax()]
```
All elements of the list must succeed in order for the operator to succeed.  
| syntax | args | result | note |
|---|---|---|---|
| [int, string] | ["1", "a"] | [1, "a"] |-|
| [int] | ["1", "a"]  | [1]| remaining: ["a"] |
| [string] | ["1", "a"]  | ["1"] | remaining: ["a"] |-|
| [{key, float}] | ["1.2"] | [{key, 1.2}] |-|
| [int, int] | ["1", "a"] | error | "a" isn't an int |
| [int, string, int] | error | missing third arg |
| [{opt1, int}, {opt2, int}] | ["1", "a"] | error | "a" isn't an int |

### operator `any`
format:
```
{any, [syntax()]}
```
The parser will try to consume arguments as long as one of syntax matches. If an element of the syntax fails, the operator fails.  
| syntax | args | result | note |
|---|---|---|---|
| {any, [int]} | ["1", "2", "abc"] | [1, 2] | remaining: ["abc"] |
| {any, [{key, int}]} | ["1", "2"] | [{key, 1}, {key, 2}] |-|
| {any, [int, {s, string}]} | ["1", "2", "abc", "3"] | [1, 2, {s, "abc"}, 3] |-|
| {any, [string]} | ["1", "-o", "abc", "3"] | ["1", "-o", "abc", "3"] | even if "-o" is an option|

No matter the number of matching element, `any` will always succeed. If nothing matches no arguments will be consumed.

> [!NOTE]
> Keep in mind that if the list given to `any` contains types like `string` or `binary`, it will consume all the remaining arguments.  
> `{any, [string, custom_type]}`, `custom_type` will never be executed because the type `string` will always consume argument

### operator `first`
format:
```
{first, [syntax()]}
```
The parser will return the first element of the syntax to succeed.
It'll fail if no element matches.  
The following table use `Args = ["a", "b", "1"]`
| syntax | result | remaining | note |
|---|---|---|---|
| {first, [int]} | [1] | ["2", "a", "3", "b"] |-|
| {first, [{opt, int}]} | [{opt, 1}] | ["a", "3", "b"] |-|
| {any, [int, {b, binary}]} | [1, 2, {b, <<"a">>}, 3, {b, <<"b">>}] | [] |-|
| {any, [string]} | ["1", "2", "a", "3", "b"] | [] |-|

### custom type

Sometime, you need to perfom some operations on an argument or do more complexe verifications. This is what custom type is for.  
A custom type is a function that takes a list of arguments and return the formated / checked value to the parser:
```
-spec fun((Args :: args()) -> {ok, Value :: any(), Remaining :: args} | Failure :: any()).
```
- `Args`: The list of arguments not yet consumed by the parser
- `Value`: The Value you want to return to the parser
- `Remaining`: The list of arguments your function didn't consumed
- `Failure`: some explanation on why the function didn't accept the argument

**Example 1**:  
Let say your script has an option `-f FILE` where `FILE` must be an existing file. In this case the type `string` won't be enought. You could write your own function to perform this check:
```erlang
existing_file([File | RemainingArgs]) ->
    case filelib:is_regular(File) of
        true ->
            {ok, File, RemainingArgs};
        _ ->
            {not_a_file, File}
    end.
```
To use your custom type:
```erlang
Spec = #{ syntax => {any, [file]},
          definitions => #{ file => erlarg:opt({"-f", "--file"}, existing_file),
                            existing_file => fun existing_file/1 } }.
```
or simply:
```erlang
Spec = {any, [{file, erlarg:opt({"-f", "--file"}, fun existing_file/1)}]}.
```

**Example 2**:  
In this case, your script needs to fetch the informations of a particular user from a config file with the option `--consult USERS_FILE USER_ID` where `USERS_FILE` is the file containing the users data and `USER_ID` is the id of the user:
```erlang
get_user_config([DatabaseFile, UserID | RemainingArgs]) ->
    case file:consult(DatabaseFile) of
        {ok, Users} ->
            case proplists:get_value(UserID, Users, not_found) of
                not_found -> {user_not_found, UserID};
                UserData -> {ok, UserData, RemainingArgs}
            end;
        Error -> {cannot_consult, DatabaseFile, Error}
    end;
get_user_config(_) ->
    {badarg, missing_arguments}.
```
